use crate::config::Config;
use crate::koala::{get_user_info, UserIdFromTokenError};
use crate::routes::appdata::WebData;
use crate::routes::error::{Error, WebResult};
use crate::routes::redirect::Redirect;
use actix_web::http::StatusCode;
use actix_web::web;
use dal::database::{OAuthAccess, User};
use serde::Deserialize;
use tap::TapFallible;
use tracing::{trace, warn};

#[derive(Debug, Deserialize)]
pub struct Query {
    /// The OAuth code generated by Koala
    code: String,
}

/// Complete the Koala login flow.
/// The provided code must be generated by Koala.
///
/// Creates a session for the requesting user.
///
/// # Errors
///
/// - If the provided `code` isn't valid
/// - If something went wrong
pub async fn login(data: WebData, query: web::Query<Query>) -> WebResult<Redirect> {
    // Complete the OAuth2 flow by exchanging the code for a token pair
    trace!("Exchanging received code for Oauth2 tokens with Koala");

    let oauth_api = data.koala.oauth_api(data.config.oauth_client_config());

    let oauth_tokens = oauth_api
        .exchange_login_code(&query.code)
        .await
        .map_err(Error::Koala)?;

    let userinfo = oauth_api
        .get_userinfo(&oauth_tokens.access_token)
        .await
        .map_err(Error::Koala)?;

    let user = match User::get_by_id(&data.db, userinfo.koala_id).await? {
        Some(mut u) => {
            trace!("User already exists in database, setting new OAuth2 tokens");

            // Update the tokens for this user
            u.set_tokens(
                oauth_tokens.access_token,
                oauth_tokens.refresh_token,
                oauth_tokens.expires_at,
            )
            .await?;
            u
        }
        // No user exists yet, create one
        None => {
            trace!("User does not yet exist in database, creating new user.");

            let user_info = get_user_info(&data.config, &oauth_tokens.access_token)
                .await
                .map_err(|e| match e {
                    UserIdFromTokenError::Reqwest(e) => Error::Koala(e),
                    UserIdFromTokenError::IntParse(e) => {
                        warn!("Failed to parse int: {e}");
                        Error::Other(StatusCode::INTERNAL_SERVER_ERROR)
                    }
                })?;

            trace!("Is signed-in user admin?: {}", user_info.is_admin);

            let name =
                get_user_name(&data.config, user_info.koala_id, &oauth_tokens.access_token).await?;
            User::create(
                &data.db,
                user_info.koala_id,
                OAuthAccess {
                    access_token: oauth_tokens.access_token,
                    refresh_token: oauth_tokens.refresh_token,
                    expires_at,
                },
                user_info.is_admin,
                name,
            )
            .await?
        }
    };

    trace!("Creating new session for user.");
    let session_id = user.create_session().await?;
    let redirect_to = format!(
        "{}?session_id={}&is_admin={}",
        data.config.login_complete_redirect_uri, session_id, user.is_admin
    );
    Ok(Redirect::new(redirect_to))
}

async fn get_user_name(config: &Config, koala_id: i32, access_token: &str) -> WebResult<String> {
    // Retrieve the user's name
    let user_info = crate::koala::get_member(config, access_token, koala_id)
        .await
        .tap_err(|e| warn!("Failed to retrieve user info from Koala: {e}"))
        .map_err(Error::Koala)?;

    let user_name = if let Some(infix) = user_info.infix {
        format!("{} {} {}", user_info.first_name, infix, user_info.last_name)
    } else {
        format!("{} {}", user_info.first_name, user_info.last_name)
    };

    Ok(user_name)
}
